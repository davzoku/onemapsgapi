url <- "https://developers.onemap.sg/privateapi/routingsvc/route?"
route <- str_to_lower(route)
query <- paste(url,
"start=", str_c(start, collapse = ","),
"&end=", str_c(end, collapse = ","),
"&routeType=", route,
"&token=", token,
sep = "")
if (route == "pt") {
query <- paste(query,
"&date=", date,
"&time=", time,
"&mode=", str_to_upper(mode),
"&maxWalkDistance=", max_dist,
"&numItineraries=", n_itineraries,
sep = "")
}
response <- GET(query)
# error handling
if (http_error(response)) {
status <- status_code(response)
output <- NULL
warning(paste("The request produced a", status, "error", sep = " "))
# break function
return(output)
}
# else return output
output <- content(response)
# error check: invalid parameters
if (names(output)[1] == "error") {
warning(output$error)
output <- NULL
return(output)
} else if (route == "pt") {
# clean raw JSON output to tibble, with each itinerary representing one row.
# in raw output, each itinerary contains a list named legs. the sum of distances covered in each leg, and number of legs, is extracted.
n_legs <- map_int(output$plan$itineraries, function(x) length(x$legs))
total_dist <- map_dbl(output$plan$itineraries, function(x) sum(map_dbl(x$legs, function(x) x$distance)))
# create itineraries df
itineraries <- output$plan$itineraries %>%
map(function(x) replace(x, 12, 0)) %>% # replace legs list with 0
reduce(bind_rows) %>%
bind_cols(total_dist = total_dist) %>%
mutate(legs = n_legs)
# create other columns df
query_details <- tibble(date = rep(output$plan$date, nrow(itineraries)),
from_lon = rep(output$plan$from$lon, nrow(itineraries)),
from_lat = rep(output$plan$from$lat, nrow(itineraries)),
to_lon = rep(output$plan$to$lon, nrow(itineraries)),
to_lat = rep(output$plan$to$lat, nrow(itineraries)))
result <- query_details %>%
bind_cols(itineraries)  %>%
select(.data$from_lon, .data$from_lat, .data$to_lon, .data$to_lat,
total_time = .data$duration, .data$total_dist, .data$fare,
transit = .data$transitTime, wait = .data$waitingTime, walk_dist = .data$walkDistance,
walk_limit_exceeded = .data$walkLimitExceeded, elevation_lost = .data$elevationLost,
elevation_gain = .data$elevationGained, .data$transfers, .data$legs, slope = .data$tooSloped,
.data$date, start_time = .data$startTime, end_time = .data$endTime)
} else {
route_name <- str_c(output$route_name, collapse = ",")
# route instructions comes as a list of steps, with each step being an unnamed list of instructions.
# Concat each part of a step using tab, concat steps using newline.
route_instructions <- output$route_instructions %>%
map(str_c, collapse = "\t") %>%
str_c(collapse = "\n")
result <- tibble(from_lon = start[1], from_lat = start[2],
to_lon = end[1], to_lat = end[2],
total_time = output$route_summary$total_time,
total_dist = output$route_summary$total_dist,
start = output$route_summary$start_point,
end = output$route_summary$end_point,
route_geom = output$route_geometry,
route_name = route_name,
route_instruct = route_instructions)
}
# create status_info if requested by user
if (status_info) {
if (route == "pt") {
status_info <- list(request_params = output$requestParameters,
debug_output = flatten(output$debugOutput),
elevation = output$elevationMetadata)
} else {
status_info <- list(status = output$status,
status_msg = output$status_message)
}
output <- list(status_info = status_info,
result = result)
}
output
}
get_route2(token, c(1.319728, 103.8421), c(1.319728905, 103.8421581),
"pt", mode = "transit", status_info = TRUE)
build()
check()
#' Get Population Data
#'
#' @description
#' This function is a wrapper for the \href{https://docs.onemap.sg/#population-query}{Population Query API}. It only allows for querying of one data type (i.e. one of the API endpoints) for a particular town and year.
#'
#' @param token User's API token. This can be retrieved using \code{\link{get_token}}
#' @param data_type Type of data to be retrieved, should correspond to one of the API endpoints. E.g. to get economic status data, \code{data_type = "getEconomicStatus"}. The API endpoints can be found on the documentation page.
#' @param planning_area Town for which the data should be retrieved.
#' @param year Year for which the data should be retrieved.
#' @param gender Optional, if specified only records for that gender will be returned. This parameter is only valid for the \code{"getEconomicStatus"}, \code{"getEthnicGroup"}, \code{"getMaritalStatus"} and \code{"getPopulationAgeGroup"} endpoints. If specified for other endpoints, the parameter will be dropped.
#' @param sleep Optional sleep time for iterative calls
#' @return A tibble with 1 row and values for all the corresponding variables returned by the API endpoint.
#' If gender is not specified for endpoints with a gender parameter, records for total, male and female will be returned. The notable exception to this is for the \code{"getEthnicGroup"} endpoint, which only returns the total record if gender is not specified. This is because by default, this is the only API endpoint with a gender parameter that does not return gender breakdown by default.
#' If an error occurs, the function will return a NULL value
#' @export
#'
#' @examples
#' # returns data
#' \donttest{get_pop_query(token, "getOccupation", "Bedok", "2010")}
#' \donttest{get_pop_query(token, "getEthnicStatus", "Central", "2010")}
#' \donttest{get_pop_query(token, "getMaritalStatus", "Central", "2010")}
#' \donttest{get_pop_query(token, "getEconomicStatus", "Yishun", "2010", "female")}
#'
#' # returns NULL, warning message shows status code
#' \donttest{get_pop_query("invalid_token", "getOccupation", "Bedok", "2010")}
#'
#' # returns NULL, warning message shows the error
#' \donttest{get_pop_query(token, "getInvalidData", "Bedok", "2010")}
#' \donttest{get_pop_query(token, "getOccupation", "Bedok", "fakeyear")}
#' \donttest{get_pop_query(token, "getReligion", "faketown", "2010")}
get_pop_query <- function(token, data_type, planning_area, year, gender = NULL, sleep = NULL) {
# clean planning_area
planning_area <- str_replace(planning_area, " ", "+")
# query API
url <- "https://developers.onemap.sg/privateapi/popapi/"
query <- paste(url, data_type, "?",
"token=", token,
"&planningArea=", planning_area,
"&year=", year,
"&gender=", gender,
sep = "")
response <- GET(query)
if (!is.null(sleep)) {Sys.sleep(sleep)}
# error handling
if (http_error(response)) {
status <- status_code(response)
output <- NULL
warning(paste("The request produced a", status, "error", sep = " "))
} else {
output <- content(response)
# error check: invalid parameters
if ("error" %in% names(output)) {
warning(output$error)
output <- NULL
} else if (class(output) == "character") {
warning(output)
output <- NULL
# error check: no results
} else if ("Result" %in% names(output)) {
warning(output$Result)
output <- NULL
# else return output
} else {
# replace NULLs with NA so tibble is of consistent length
output <- output %>%
map(function(i) map(i, function(j) ifelse(is.null(j), NA, j))) %>%
# bind rows and turn into tibble
reduce(bind_rows) %>% as_tibble()
# attach gender = Total for output without gender,
# and ensure if gender is not specified, Total data is returned - i.e. fix Economic Status and Marital Status
if (data_type %in% c("getEconomicStatus", "getMaritalStatus")) {
if (is.null(gender)) {
output <- output %>%
select(planning_area, year, gender, everything())
total <- colSums(output[ , -(1:3)], na.rm = FALSE) %>%
t() %>% as_tibble() %>%
mutate(planning_area = planning_area,
year = as.integer(year),
gender = "Total") %>%
select(planning_area, year, gender, everything())
output <- output %>%
bind_rows(total)
}
} else if (!(data_type %in% c("getEthnicGroup", "getPopulationAgeGroup") & !is.null(gender))) {
output <- output %>% mutate(gender = "Total")
}
}
}
output
}
build()
?get_pop_query
get_pop_query("invalid_token", "getOccupation", "Bedok", "2010")
get_pop_query(token, "getInvalidData", "Bedok", "2010")
get_pop_query(token, "getOccupation", "Bedok", "fakeyear")
get_pop_query(token, "getReligion", "faketown", "2010")
rm(get_pop_query())
rm(get_pop_query
)
rm(get_pop_query2)
rm(get_route2)
get_pop_query("invalid_token", "getOccupation", "Bedok", "2010")
build()
get_pop_query("invalid_token", "getOccupation", "Bedok", "2010")
library(knitr)
library(kableExtra)
opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
NOT_CRAN <- identical(tolower(Sys.getenv("NOT_CRAN")), "true")
opts_chunk$set(purl = NOT_CRAN)
library(onemapsgapi)
token <- get_token(Sys.getenv("onemap_email"), Sys.getenv("onemap_pw"))
# return all themes related to "hdb" or "parks"
search_themes(token, "hdb", "parks") %>%
kable() %>% kable_styling() %>%
scroll_box(height = "300px", width = "100%")
# return all possible themes
search_themes(token) %>%
kable() %>% kable_styling() %>%
scroll_box(height = "300px", width = "100%")
search_themes(token, more_info = FALSE) %>%
kable() %>% kable_styling() %>%
scroll_box(height = "300px")
search_themes("my_invalid_token")
# return all hotel data
get_theme(token, "hotels") %>%
kable() %>% kable_styling() %>%
scroll_box(height = "300px", width = "100%")
# return all monuments data within a bounding area
get_theme(token, "monuments", extents = "1.291789,%20103.7796402,1.3290461,%20103.8726032") %>%
kable() %>% kable_styling() %>%
scroll_box(height = "300px", width = "100%")
# returns a list of status tibble and output tibble
get_theme(token, "lighting", return_info = TRUE) %>%
str()
# error: output is NULL, warning message shows status code
get_theme("invalid_token", "hotels")
# error: output is NULL, warning message shows error message from request
get_theme(token, "non-existent-theme")
# error: output is query_info, warning message query did not return any records
get_theme(token, "ura_parking_lot", "1.291789,%20103.7796402,1.3290461,%20103.8726032")
# example: return occupation summary data for Bedok town in year 2010
get_pop_query(token, "getOccupation", "Bedok", "2010")
# example: endpoints with a gender parameter but gender is not specified
get_pop_query(token, "getEthnicGroup", "Bedok", "2010") %>%
kable() %>% kable_styling()
get_pop_query(token, "getMaritalStatus", "Bedok", "2010") %>%
kable() %>% kable_styling()
# example: endpoints with a gender parameter but gender specified
get_pop_query(token, "getEconomicStatus", "Yishun", "2010", "female")
# example: returns NULL, warning message shows status code
# get_pop_query("invalid_token", "getOccupation", "Bedok", "2010")
# example: returns NULL, warning message shows the error
get_pop_query(token, "getInvalidData", "Bedok", "2010")
#' Get Population Data
#'
#' @description
#' This function is a wrapper for the \href{https://docs.onemap.sg/#population-query}{Population Query API}. It only allows for querying of one data type (i.e. one of the API endpoints) for a particular town and year.
#'
#' @param token User's API token. This can be retrieved using \code{\link{get_token}}
#' @param data_type Type of data to be retrieved, should correspond to one of the API endpoints. E.g. to get economic status data, \code{data_type = "getEconomicStatus"}. The API endpoints can be found on the documentation page.
#' @param planning_area Town for which the data should be retrieved.
#' @param year Year for which the data should be retrieved.
#' @param gender Optional, if specified only records for that gender will be returned. This parameter is only valid for the \code{"getEconomicStatus"}, \code{"getEthnicGroup"}, \code{"getMaritalStatus"} and \code{"getPopulationAgeGroup"} endpoints. If specified for other endpoints, the parameter will be dropped.
#' @param sleep Optional sleep time for iterative calls
#' @return A tibble with 1 row and values for all the corresponding variables returned by the API endpoint.
#' If gender is not specified for endpoints with a gender parameter, records for total, male and female will be returned. The notable exception to this is for the \code{"getEthnicGroup"} endpoint, which only returns the total record if gender is not specified. This is because by default, this is the only API endpoint with a gender parameter that does not return gender breakdown by default.
#' If an error occurs, the function will return a NULL value
#' @export
#'
#' @examples
#' # returns data
#' \donttest{get_pop_query(token, "getOccupation", "Bedok", "2010")}
#' \donttest{get_pop_query(token, "getEthnicStatus", "Central", "2010")}
#' \donttest{get_pop_query(token, "getMaritalStatus", "Central", "2010")}
#' \donttest{get_pop_query(token, "getEconomicStatus", "Yishun", "2010", "female")}
#'
#' # returns NULL, warning message shows status code
#' \donttest{get_pop_query("invalid_token", "getOccupation", "Bedok", "2010")}
#'
#' # returns NULL, warning message shows the error
#' \donttest{get_pop_query(token, "getInvalidData", "Bedok", "2010")}
#' \donttest{get_pop_query(token, "getOccupation", "Bedok", "fakeyear")}
#' \donttest{get_pop_query(token, "getReligion", "faketown", "2010")}
get_pop_query2 <- function(token, data_type, planning_area, year, gender = NULL, sleep = NULL) {
# clean planning_area
planning_area <- str_replace(planning_area, " ", "+")
# query API
url <- "https://developers.onemap.sg/privateapi/popapi/"
query <- paste(url, data_type, "?",
"token=", token,
"&planningArea=", planning_area,
"&year=", year,
"&gender=", gender,
sep = "")
response <- GET(query)
if (!is.null(sleep)) {Sys.sleep(sleep)}
# error handling
if (http_error(response)) {
status <- status_code(response)
output <- NULL
warning(paste("The request produced a", status, "error", sep = " "))
} else {
output <- content(response)
# error check: invalid parameters
if ("error" %in% names(output)) {
warning(output$error)
output <- NULL
} else if (class(output) == "character") {
warning(output)
output <- NULL
# error check: no results
} else if ("Result" %in% names(output)) {
warning(output$Result)
output <- NULL
# else return output
#    } else {
# replace NULLs with NA so tibble is of consistent length
output <- output %>%
map(function(i) map(i, function(j) ifelse(is.null(j), NA, j))) %>%
# bind rows and turn into tibble
reduce(bind_rows) %>% as_tibble()
# attach gender = Total for output without gender,
# and ensure if gender is not specified, Total data is returned - i.e. fix Economic Status and Marital Status
if (data_type %in% c("getEconomicStatus", "getMaritalStatus")) {
if (is.null(gender)) {
output <- output %>%
select(planning_area, year, gender, everything())
total <- colSums(output[ , -(1:3)], na.rm = FALSE) %>%
t() %>% as_tibble() %>%
mutate(planning_area = planning_area,
year = as.integer(year),
gender = "Total") %>%
select(planning_area, year, gender, everything())
output <- output %>%
bind_rows(total)
}
} else if (!(data_type %in% c("getEthnicGroup", "getPopulationAgeGroup") & !is.null(gender))) {
output <- output %>% mutate(gender = "Total")
}
}
}
output
}
get_pop_query2(token, "getInvalidData", "Bedok", "2010")
#' Get Population Data
#'
#' @description
#' This function is a wrapper for the \href{https://docs.onemap.sg/#population-query}{Population Query API}. It only allows for querying of one data type (i.e. one of the API endpoints) for a particular town and year.
#'
#' @param token User's API token. This can be retrieved using \code{\link{get_token}}
#' @param data_type Type of data to be retrieved, should correspond to one of the API endpoints. E.g. to get economic status data, \code{data_type = "getEconomicStatus"}. The API endpoints can be found on the documentation page.
#' @param planning_area Town for which the data should be retrieved.
#' @param year Year for which the data should be retrieved.
#' @param gender Optional, if specified only records for that gender will be returned. This parameter is only valid for the \code{"getEconomicStatus"}, \code{"getEthnicGroup"}, \code{"getMaritalStatus"} and \code{"getPopulationAgeGroup"} endpoints. If specified for other endpoints, the parameter will be dropped.
#' @param sleep Optional sleep time for iterative calls
#' @return A tibble with 1 row and values for all the corresponding variables returned by the API endpoint.
#' If gender is not specified for endpoints with a gender parameter, records for total, male and female will be returned. The notable exception to this is for the \code{"getEthnicGroup"} endpoint, which only returns the total record if gender is not specified. This is because by default, this is the only API endpoint with a gender parameter that does not return gender breakdown by default.
#' If an error occurs, the function will return a NULL value
#' @export
#'
#' @examples
#' # returns data
#' \donttest{get_pop_query(token, "getOccupation", "Bedok", "2010")}
#' \donttest{get_pop_query(token, "getEthnicStatus", "Central", "2010")}
#' \donttest{get_pop_query(token, "getMaritalStatus", "Central", "2010")}
#' \donttest{get_pop_query(token, "getEconomicStatus", "Yishun", "2010", "female")}
#'
#' # returns NULL, warning message shows status code
#' \donttest{get_pop_query("invalid_token", "getOccupation", "Bedok", "2010")}
#'
#' # returns NULL, warning message shows the error
#' \donttest{get_pop_query(token, "getInvalidData", "Bedok", "2010")}
#' \donttest{get_pop_query(token, "getOccupation", "Bedok", "fakeyear")}
#' \donttest{get_pop_query(token, "getReligion", "faketown", "2010")}
get_pop_query2 <- function(token, data_type, planning_area, year, gender = NULL, sleep = NULL) {
# clean planning_area
planning_area <- str_replace(planning_area, " ", "+")
# query API
url <- "https://developers.onemap.sg/privateapi/popapi/"
query <- paste(url, data_type, "?",
"token=", token,
"&planningArea=", planning_area,
"&year=", year,
"&gender=", gender,
sep = "")
response <- GET(query)
if (!is.null(sleep)) {Sys.sleep(sleep)}
# error handling
if (http_error(response)) {
status <- status_code(response)
output <- NULL
warning(paste("The request produced a", status, "error", sep = " "))
} else {
output <- content(response)
# error check: invalid parameters
if ("error" %in% names(output)) {
warning(output$error)
output <- NULL
} else if (class(output) == "character") {
warning(output)
output <- NULL
# error check: no results
} else if ("Result" %in% names(output)) {
warning(output$Result)
output <- NULL
# else return output
} else {
# replace NULLs with NA so tibble is of consistent length
output <- output %>%
map(function(i) map(i, function(j) ifelse(is.null(j), NA, j))) %>%
# bind rows and turn into tibble
reduce(bind_rows) %>% as_tibble()
# attach gender = Total for output without gender,
# and ensure if gender is not specified, Total data is returned - i.e. fix Economic Status and Marital Status
if (data_type %in% c("getEconomicStatus", "getMaritalStatus")) {
if (is.null(gender)) {
output <- output %>%
select(planning_area, year, gender, everything())
total <- colSums(output[ , -(1:3)], na.rm = FALSE) %>%
t() %>% as_tibble() %>%
mutate(planning_area = planning_area,
year = as.integer(year),
gender = "Total") %>%
select(planning_area, year, gender, everything())
output <- output %>%
bind_rows(total)
}
} else if (!(data_type %in% c("getEthnicGroup", "getPopulationAgeGroup") & !is.null(gender))) {
output <- output %>% mutate(gender = "Total")
}
}
}
output
}
get_pop_query2(token, "getInvalidData", "Bedok", "2010")
build()
get_pop_query(token, "getInvalidData", "Bedok", "2010")
body(get_pop_query)
library(devtools)
library(onemapsgapi)
body(get_pop_query)
build()
body(get_pop_query)
install.packages("C:/Users/jolen/OneDrive/Documents/QMSS/GR5072_Modern_Data_Structures/Lim_Jolene/Final_Proj/onemapsgapi_0.1.0.tar.gz",repos=NULL,type="source")
require("onemapsgapi")
# example: only route data, route = drive
get_route(token, c(1.319728, 103.8421), c(1.319728905, 103.8421581), "drive") %>%
kable() %>% kable_styling() %>%
scroll_box(width = "100%")
library(onemapsgapi)
# example: only route data, route = drive
get_route(token, c(1.319728, 103.8421), c(1.319728905, 103.8421581), "drive") %>%
kable() %>% kable_styling() %>%
scroll_box(width = "100%")
get_route(token, c(1.319728, 103.8421), c(1.319728905, 103.8421581), "drive")
token <- get_token(Sys.getenv("onemap_email"), Sys.getenv("onemap_pw"))
get_route(token, c(1.319728, 103.8421), c(1.319728905, 103.8421581), "drive")
get_route(token, c(1.319728, 103.8421), c(1.319728905, 103.8421581), "pt",
mode = "bus", max_dist = 300, n_itineraries = 2)
# example: only route data, route = pt
get_route(token, c(1.319728, 103.8421), c(1.319728905, 103.8421581), "pt",
mode = "bus", max_dist = 300, n_itineraries = 2) %>%
kable() %>% kable_styling() %>%
scroll_box(width = "100%")
get_route(token, c(1.319728, 103.8421), c(1.319728905, 103.8421581), "pt",
mode = "bus", max_dist = 300, n_itineraries = 2)
# example: only route data, route = drive
get_route(token, c(1.319728, 103.8421), c(1.319728905, 103.8421581), "drive") %>%
kable() %>% kable_styling() %>%
scroll_box(width = "100%")
# example: only route data, route = drive
get_route(token, c(1.319728, 103.8421), c(1.319728905, 103.8421581), "drive") %>%
kable() %>% kable_styling() %>%
scroll_box(width = "100%")
library(dplyr)
# example: only route data, route = drive
get_route(token, c(1.319728, 103.8421), c(1.319728905, 103.8421581), "drive") %>%
kable() %>% kable_styling() %>%
scroll_box(width = "100%")
library(kable)
library(knitr)
library(kableExtra)
# example: only route data, route = drive
get_route(token, c(1.319728, 103.8421), c(1.319728905, 103.8421581), "drive") %>%
kable() %>% kable_styling() %>%
scroll_box(width = "100%")
# example: only route data, route = pt
get_route(token, c(1.319728, 103.8421), c(1.319728905, 103.8421581), "pt",
mode = "bus", max_dist = 300, n_itineraries = 2) %>%
kable() %>% kable_styling() %>%
scroll_box(width = "100%")
check()
body(get_route)
build()
library(devtools)
build()
install.packages(""C:/Users/jolen/OneDrive/Documents/QMSS/GR5072_Modern_Data_Structures/Lim_Jolene/Final_Proj/onemapsgapi_0.1.0.tar.gz",repos=NULL,type="source")
library(onemapsgapi)
install.packages("C:/Users/jolen/OneDrive/Documents/QMSS/GR5072_Modern_Data_Structures/Lim_Jolene/Final_Proj/onemapsgapi_0.1.0.tar.gz",repos=NULL,type="source")
library(onemapsgapi)
check()
check()
build()
build()
library(devtools)
build()
build()
remove.packages("onemapsgapi", lib="~/R/win-library/3.6")
devtools::build()
document()
library(devtools)
document()
build()
install()
check()
